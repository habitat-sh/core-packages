program="gcc"
native_target="${pkg_target%%-*}-unknown-linux-gnu"

pkg_name="gcc-base"
pkg_origin="core"
pkg_version="13.2.0"
pkg_maintainer="The Habitat Maintainers <humans@habitat.sh>"
pkg_description="\
The GNU Compiler Collection (GCC) is a compiler system produced by the GNU \
Project supporting various programming languages. GCC is a key component of \
the GNU toolchain and the standard compiler for most Unix-like operating \
systems.\
"
pkg_upstream_url="https://gcc.gnu.org/"
pkg_license=('GPL-3.0-or-later WITH GCC-exception-3.1' 'LGPL-3.0-or-later')
pkg_source="http://ftp.gnu.org/gnu/$program/${program}-${pkg_version}/${program}-${pkg_version}.tar.xz"
pkg_shasum="e275e76442a6067341a27f04c5c6b83d8613144004c0413528863dc6b5c743da"
pkg_dirname="${program}-${pkg_version}"

pkg_deps=(
	core/glibc
	core/hab-cc-wrapper
)

pkg_build_deps=(
	core/linux-headers
	core/binutils-stage1
	core/gcc-stage1-with-glibc
	core/gmp-stage1
	core/isl-stage1
	core/mpfr-stage1
	core/libmpc-stage1
	core/zlib-stage1
	core/zstd-stage1
	core/m4-stage0
	core/flex-stage0
	core/xz-stage0
	core/build-tools-texinfo
	core/build-tools-bison
)

pkg_bin_dirs=(bin)
pkg_include_dirs=(include)
pkg_lib_dirs=(lib lib64)

do_prepare() {
	local libc
	local linux_headers
	local dynamic_linker

	libc="$(pkg_path_for glibc)"
	linux_headers="$(pkg_path_for linux-headers)"

	case $pkg_target in
	aarch64-linux)
		dynamic_linker="$libc/lib/ld-linux-aarch64.so.1"
		;;
	x86_64-linux)
		dynamic_linker="$libc/lib/ld-linux-x86-64.so.2"
		;;
	esac
	# This plan does not require a full bootstrap build of gcc because
	# core/gcc-stage1 is a fully bootstrapped compiler of the same version.
	# Bootstrapping is only recommended when there is a major version difference
	# between the build compiler and the built compiler.
	# To know more about the gcc bootstrap process and it's configuration
	# check out the following link: https://gcc.gnu.org/install/build.html

	# We add extra flags which will get passed to the target xgcc compiler
	# that is used to compile the final libraries such as libatomic, libgomp,
	# libstdc++, libgcc, libquadmath, libssp among other.
	#
	# Explanation of flags used
	# * -B$(pkg_path_for glibc)/lib
	#   Tells gcc where to find C runtime start files (crt{i,o,n}.o) These are
	#   provided by glibc and are required to be linked into all executables.
	# * -L$(pkg_path_for glibc)/lib
	#   Tells gcc where to find the C library, usually libc and libm.
	# * -idirafter $(pkg_path_for glibc)/include
	#   Tells gcc where to find the C library's header files
	# * -idirafter $(pkg_path_for linux-headers)/include
	#   Tells gcc where to find the linux header files.
	#   The C library's header files requires the linux headers.
	#   The linux headers folder must always come after the C library's headers
	#   otherwise they will not get included in the correct order.
	export FLAGS_FOR_TARGET="-B${libc}/lib \
		-L${libc}/lib \
		-idirafter ${libc}/include \
		-idirafter ${linux_headers}/include"

	# Extra linking flags passed to gcc so that excutables generated by
	# target xgcc compiler will use the correct dynamic linker from our glibc.
	export LDFLAGS_FOR_TARGET="${LDFLAGS} -Wl,-dynamic-linker=${dynamic_linker}"

	# Extra flags that must be passed to intermediate xgcc/xg++ bootstrapping compilers.
	# These flags are similar to the what we pass to the target xgcc/xg++ compilers.
	# We need to add '-O2' to ensure optimizations are enabled during compilation.
	export BOOT_CFLAGS="${FLAGS_FOR_TARGET} -O2"

	# Extra linking flags that must be passed to intermediate xgcc/xg++ bootstrapping compilers
	# These flags are similar to the what we pass to the target xgcc/xg++ compilers.
	export BOOT_LDFLAGS="${LDFLAGS_FOR_TARGET}"

	# Tell gcc not to look under the default `/lib/` and `/usr/lib/` directories
	# for libraries
	#
	# Thanks to: https://raw.githubusercontent.com/NixOS/nixpkgs/release-22.05/pkgs/development/compilers/gcc/gcc-12-no-sys-dirs.patch
	# shellcheck disable=SC2002
	patch -p1 <"$PLAN_CONTEXT/gcc-12-no-sys-dirs.patch"
   # build error with newer glibc. 
   # Thanks to https://github.com/llvm/llvm-project/commit/d7bead833631486e337e541e692d9b4a1ca14edd
   patch -p1 <"$PLAN_CONTEXT/remove_crypt-and-crypt_r-interceptors.patch"
	build_line "Setting FLAGS_FOR_TARGET=${FLAGS_FOR_TARGET}"
	build_line "Setting LDFLAGS_FOR_TARGET=${LDFLAGS_FOR_TARGET}"
	build_line "Setting BOOT_CFLAGS=${BOOT_CFLAGS}"
	build_line "Setting BOOT_LDFLAGS=${BOOT_LDFLAGS}"
}

do_build() {
	mkdir -v build
	pushd build || exit 1

	# We force the usage of the correct linker via the 'LD' parameter.
	# If we do not do this, it will use the linker specified by the compiler.
	# In this case the compiler is the 'core/build-tools-gcc' compiler and it
	# would specify the 'core/build-tools-binutils' ld.
	../configure \
		LDFLAGS_FOR_TARGET="${LDFLAGS_FOR_TARGET}" \
		CPPFLAGS_FOR_TARGET="${CPPFLAGS}" \
		CFLAGS_FOR_TARGET="${CFLAGS}" \
		CXXFLAGS_FOR_TARGET="${CXXFLAGS}" \
		LD="$(pkg_path_for binutils-stage1)"/bin/ld \
		--prefix="$pkg_prefix" \
		--with-gmp="$(pkg_path_for gmp-stage1)" \
		--with-isl="$(pkg_path_for isl-stage1)" \
		--with-mpfr="$(pkg_path_for mpfr-stage1)" \
		--with-mpc="$(pkg_path_for libmpc-stage1)" \
		--with-zstd="$(pkg_path_for zstd-stage1)" \
		--with-native-system-header-dir="$(pkg_path_for glibc)/include" \
		--enable-default-pie \
		--enable-default-ssp \
		--disable-multilib \
		--with-system-zlib \
		--enable-languages=c,c++

	# These flags are passed directly to make as they cannot be
	# configured via the configure script.
	# It is important to not run this build in parallel due to this
	# race condition: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106162
	make \
		FLAGS_FOR_TARGET="${FLAGS_FOR_TARGET}" \
		BOOT_CFLAGS="${BOOT_CFLAGS}" \
		BOOT_LDFLAGS="${BOOT_LDFLAGS}" \
		-j "$(nproc)" \
		--output-sync

	popd || exit 1
}

do_install() {
	# Determine the target prefix
	local target_prefix
	target_prefix=$(./config.guess)

	pushd build || exit 1
	make install

	# Many packages use the name cc to call the C compiler
	ln -sv gcc "$pkg_prefix/bin/cc"

	wrap_binary "${target_prefix}-c++"
	wrap_binary "${target_prefix}-g++"
	wrap_binary "${target_prefix}-gcc"
	wrap_binary "${target_prefix}-gcc-${pkg_version}"

	wrap_binary "c++"
	wrap_binary "g++"
	wrap_binary "gcc"
	wrap_binary "cpp"

	popd || exit 1
}

wrap_binary() {
	local binary
	local env_prefix
	local hab_cc_wrapper
	local binutils
	local linux_headers
	local libc
	local wrapper_binary
	local actual_binary
	local dynamic_linker

	binary="$1"
	env_prefix="GCC"
	hab_cc_wrapper="$(pkg_path_for hab-cc-wrapper)"
	binutils="$(pkg_path_for binutils-stage1)"
	linux_headers="$(pkg_path_for linux-headers)"
	libc="$(pkg_path_for glibc)"
	wrapper_binary="$pkg_prefix/bin/$binary"
	actual_binary="$pkg_prefix/bin/$binary.real"

	case $pkg_target in
	aarch64-linux)
		dynamic_linker="$libc/lib/ld-linux-aarch64.so.1"
		;;
	x86_64-linux)
		dynamic_linker="$libc/lib/ld-linux-x86-64.so.2"
		;;
	esac

	build_line "Adding wrapper for $binary"
	mv -v "$wrapper_binary" "$actual_binary"

	sed "$PLAN_CONTEXT/cc-wrapper.sh" \
		-e "s^@env_prefix@^${env_prefix}^g" \
		-e "s^@executable_name@^${binary}^g" \
		-e "s^@wrapper@^${hab_cc_wrapper}/bin/hab-cc-wrapper^g" \
		-e "s^@program@^${actual_binary}^g" \
		-e "s^@ld_bin@^${binutils}/bin^g" \
		-e "s^@dynamic_linker@^${dynamic_linker}^g" \
		-e "s^@c_start_files@^${libc}/lib^g" \
		-e "s^@c_std_libs@^${libc}/lib^g" \
		-e "s^@c_std_headers@^${libc}/include:${linux_headers}/include^g" \
		>"$wrapper_binary"

	chmod 755 "$wrapper_binary"
}

do_strip() {
	return 0
}
